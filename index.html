<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A2A Traffic - Agent Protocol Communication</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=JetBrains+Mono:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: #0a0a0f;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .content {
            position: relative;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        .logo {
            font-family: 'Space Mono', monospace;
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: 700;
            letter-spacing: 0.15em;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #00d9ff 0%, #00ff88 50%, #ff3366 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(0, 217, 255, 0.3);
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .tagline {
            font-size: clamp(0.7rem, 2vw, 1rem);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 3rem;
            font-weight: 300;
        }

        .cta {
            pointer-events: auto;
            display: inline-block;
            padding: 1.2rem 3rem;
            background: rgba(0, 217, 255, 0.1);
            border: 2px solid rgba(0, 217, 255, 0.5);
            color: #00d9ff;
            text-decoration: none;
            font-size: clamp(0.8rem, 2vw, 1.1rem);
            letter-spacing: 0.2em;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .cta::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 217, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .cta:hover::before {
            left: 100%;
        }

        .cta:hover {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.4);
            transform: translateY(-2px);
        }

        .footer {
            position: fixed;
            bottom: 2rem;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.8rem;
            opacity: 1;
            letter-spacing: 0.1em;
            pointer-events: none;
            z-index: 10;
        }

        .footer a {
            color: #00d9ff;
            text-decoration: none;
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        .footer a:hover {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .logo {
                letter-spacing: 0.1em;
            }
            
            .tagline {
                letter-spacing: 0.2em;
            }
            
            .cta {
                padding: 1rem 2rem;
                letter-spacing: 0.15em;
            }
        }
    </style>
</head>
<body>
    <canvas id="network"></canvas>
    
    <div class="content">
        <h1 class="logo">A2A TRAFFIC</h1>
        <p class="tagline">Agent Protocol Communication</p>
        <a href="https://app.fleetprompt.com/marketplace?q=A2ATraffic" class="cta">DISCOVER ON FLEETPROMPT â†’</a>
    </div>

    <div class="footer">
        &copy; <span id="currentYear"></span> A2ATraffic.com ... Powered by <a href="https://ampersandboxdesign.com">[&]</a>
    </div>

    <script>
        // Set current year dynamically
        document.getElementById("currentYear").textContent =
            new Date().getFullYear();

        const canvas = document.getElementById('network');
        const ctx = canvas.getContext('2d');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initializeGraph();
        });

        const config = {
            playerSpeed: 0.015,
            messageSpeed: 0.03,
            nodeRadius: 4,
            playerRadius: 8,
            messageRadius: 4,
            connectionOpacity: 0.12,
            minNodeSpacing: 70, // Distance between nodes
            maxConnectionDistance: 140, // Maximum distance for spatial connections

            // Player targeting behavior
            // Higher = more likely to go pick up/relay messages that are waiting at a node.
            playerSeekMessagesChance: 0.88,
            // Higher = more strongly prefer nodes with multiple waiting messages.
            playerSeekMessagesPower: 1.6,

            colors: {
                leftNodes: '#00d9ff',
                rightNodes: '#00ff88',
                leftPlayer: '#00d9ff',
                rightPlayer: '#00ff88',
                messages: ['#ff3366', '#ffaa00', '#00d9ff', '#00ff88'],
                connections: '#444466'
            }
        };

        class Node {
            constructor(x, y, side, id) {
                this.x = x;
                this.y = y;
                this.side = side; // 'left', 'right', or 'bridge'
                this.id = id;
                this.neighbors = []; // Array of {node, distance}
                this.active = false;
            }

            draw() {
                const color = this.side === 'left' ? config.colors.leftNodes : 
                             this.side === 'right' ? config.colors.rightNodes : '#9933ff';
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, config.nodeRadius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                if (this.active) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, config.nodeRadius * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }

        class Player {
            constructor(side, nodes) {
                this.side = side;
                this.color = side === 'left' ? config.colors.leftPlayer : config.colors.rightPlayer;
                this.teamColor = side === 'left' ? '#00d9ff' : '#00ff88'; // Cyan for left, green for right
                this.nodes = nodes;
                this.currentNodeIndex = 0;
                this.currentNode = nodes[0];
                this.targetNode = null;
                this.progress = 0;
                this.path = [];
                this.pathIndex = 0; // index in `path` (node-to-node)
                this.selectNewTarget();
            }

            selectNewTarget() {
                // Prefer nodes on our side that currently have one or more messages waiting.
                const availableNodes = this.nodes.filter(n => n !== this.currentNode);
                if (availableNodes.length === 0) return;

                const waitingCounts = getWaitingMessageCountsByNode();
                const hotNodes = availableNodes.filter(n => (waitingCounts.get(n) || 0) > 0);

                let chosen = null;
                if (hotNodes.length > 0 && Math.random() < config.playerSeekMessagesChance) {
                    chosen = weightedRandom(hotNodes, (n) => {
                        const c = waitingCounts.get(n) || 0;
                        return Math.pow(c, config.playerSeekMessagesPower);
                    });
                }

                if (!chosen) {
                    chosen = availableNodes[Math.floor(Math.random() * availableNodes.length)];
                }

                this.targetNode = chosen;

                // Path includes [start ... end]. If disconnected, re-roll a few times.
                let attempts = 0;
                while (attempts < 6) {
                    attempts++;
                    this.path = dijkstra(this.currentNode, this.targetNode, allNodes);
                    if (this.path && this.path.length >= 2) break;
                    this.targetNode = availableNodes[Math.floor(Math.random() * availableNodes.length)];
                }

                this.pathIndex = 0;
                this.progress = 0;
            }

            update() {
                if (!this.path || this.path.length < 2) {
                    this.selectNewTarget();
                    return;
                }

                // If already at destination node in the path, pick a new target.
                if (this.pathIndex >= this.path.length - 1) {
                    this.currentNode = this.path[this.path.length - 1];
                    this.handleMessages();
                    this.selectNewTarget();
                    return;
                }

                this.progress += config.playerSpeed;

                if (this.progress >= 1) {
                    this.pathIndex++;
                    this.progress = 0;
                    this.currentNode = this.path[this.pathIndex];

                    // Relay messages not only at the final destination, but also when passing through.
                    this.handleMessages();

                    if (this.pathIndex >= this.path.length - 1) {
                        this.selectNewTarget();
                    }
                }
            }

            handleMessages() {
                // Relay any messages that are currently waiting on this node.
                messages.forEach(msg => {
                    if (!msg.path || msg.path.length === 0) return;
                    const isWaitingHere = msg.targetNode === this.currentNode && msg.pathIndex >= msg.path.length - 1;
                    if (!isWaitingHere) return;

                    const targetSide = this.side === 'left' ? 'right' : 'left';
                    const targetNodes = targetSide === 'left' ? leftNodes : rightNodes;
                    const newTarget = targetNodes[Math.floor(Math.random() * targetNodes.length)];
                    
                    // Always send our team color back to try to convert their side.
                    msg.color = this.teamColor;
                    msg.targetNode = newTarget;
                    msg.path = dijkstra(this.currentNode, newTarget, allNodes);
                    msg.pathIndex = 0;
                    msg.progress = 0;
                    msg.bounces++;
                });
            }

            getCurrentPosition() {
                if (!this.path || this.path.length === 0) return this.currentNode;

                // If at (or beyond) the last node in the path, clamp to that node.
                if (this.pathIndex >= this.path.length - 1) {
                    const last = this.path[this.path.length - 1];
                    return { x: last.x, y: last.y };
                }

                const current = this.path[this.pathIndex];
                const next = this.path[this.pathIndex + 1];
                
                return {
                    x: current.x + (next.x - current.x) * this.progress,
                    y: current.y + (next.y - current.y) * this.progress
                };
            }

            draw() {
                const pos = this.getCurrentPosition();
                
                // Draw glow
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, config.playerRadius * 2);
                gradient.addColorStop(0, this.color + 'ff');
                gradient.addColorStop(0.5, this.color + '44');
                gradient.addColorStop(1, this.color + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, config.playerRadius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, config.playerRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        class Message {
            constructor(startNode, targetSide, color) {
                this.startNode = startNode;
                this.currentNode = startNode;
                this.targetSide = targetSide;
                this.color = color;
                this.progress = 0;
                this.pathIndex = 0;
                this.bounces = 0;
                
                // Find target node on opposite side
                const targetNodes = targetSide === 'left' ? leftNodes : rightNodes;
                this.targetNode = targetNodes[Math.floor(Math.random() * targetNodes.length)];
                this.path = dijkstra(startNode, this.targetNode, allNodes);
            }

            update() {
                if (!this.path || this.pathIndex >= this.path.length - 1) {
                    // Message reached target, wait for player to relay it
                    return true;
                }

                this.progress += config.messageSpeed;

                if (this.progress >= 1) {
                    this.pathIndex++;
                    this.progress = 0;
                    this.currentNode = this.path[this.pathIndex];
                }

                return true; // Messages never die
            }

            draw() {
                if (!this.path || this.pathIndex >= this.path.length - 1) {
                    // Draw at destination
                    const x = this.targetNode.x;
                    const y = this.targetNode.y;
                    
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, config.messageRadius * 2 * pulse);
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(0.5, this.color + '80');
                    gradient.addColorStop(1, this.color + '00');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, config.messageRadius * 2 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(x, y, config.messageRadius, 0, Math.PI * 2);
                    ctx.fill();
                    return;
                }
                
                const current = this.path[this.pathIndex];
                const next = this.path[this.pathIndex + 1];
                
                const x = current.x + (next.x - current.x) * this.progress;
                const y = current.y + (next.y - current.y) * this.progress;
                
                // Draw message with glow
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, config.messageRadius * 2);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.5, this.color + '80');
                gradient.addColorStop(1, this.color + '00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, config.messageRadius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(x, y, config.messageRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function weightedRandom(items, weightFn) {
            let total = 0;
            const weights = items.map((item) => {
                const w = Math.max(0, Number(weightFn(item)) || 0);
                total += w;
                return w;
            });

            if (total <= 0) {
                return items[Math.floor(Math.random() * items.length)];
            }

            let r = Math.random() * total;
            for (let i = 0; i < items.length; i++) {
                r -= weights[i];
                if (r <= 0) return items[i];
            }
            return items[items.length - 1];
        }

        function getWaitingMessageCountsByNode() {
            // A message is "waiting" when it has reached its target node and is awaiting relay.
            const counts = new Map();
            messages.forEach((msg) => {
                if (!msg.path || msg.path.length === 0) return;
                if (msg.pathIndex < msg.path.length - 1) return;
                const node = msg.targetNode;
                counts.set(node, (counts.get(node) || 0) + 1);
            });
            return counts;
        }

        // Dijkstra's algorithm for pathfinding
        function dijkstra(start, end, nodes) {
            if (!start || !end) return [];
            if (start === end) return [start];

            const distances = new Map();
            const previous = new Map();
            const unvisited = new Set(nodes);
            
            nodes.forEach(node => distances.set(node, Infinity));
            distances.set(start, 0);
            
            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;
                
                unvisited.forEach(node => {
                    const dist = distances.get(node);
                    if (dist < minDist) {
                        minDist = dist;
                        current = node;
                    }
                });

                // Remaining nodes are unreachable
                if (!current || minDist === Infinity) break;
                if (current === end) break;
                
                unvisited.delete(current);
                
                current.neighbors.forEach(({node: neighbor, distance}) => {
                    if (!unvisited.has(neighbor)) return;
                    
                    const alt = distances.get(current) + distance;
                    if (alt < distances.get(neighbor)) {
                        distances.set(neighbor, alt);
                        previous.set(neighbor, current);
                    }
                });
            }

            if (distances.get(end) === Infinity) {
                return [];
            }
            
            // Reconstruct path (end -> start)
            const path = [];
            let current = end;
            while (current) {
                path.unshift(current);
                if (current === start) break;
                current = previous.get(current);
            }
            
            return path;
        }

        let allNodes = [];
        let leftNodes = [];
        let rightNodes = [];
        let bridgeNodes = [];
        let leftPlayer = null;
        let rightPlayer = null;
        let messages = [];

        function initializeGraph() {
            allNodes = [];
            leftNodes = [];
            rightNodes = [];
            bridgeNodes = [];
            messages = [];
            
            // Calculate bounds to go edge-to-edge
            const padding = 20;
            const leftBounds = { 
                x: padding, 
                y: padding, 
                width: width * 0.4 - padding, 
                height: height - padding * 2 
            };
            const rightBounds = { 
                x: width * 0.6, 
                y: padding, 
                width: width * 0.4 - padding, 
                height: height - padding * 2 
            };
            const bridgeBounds = { 
                x: width * 0.42, 
                y: padding, 
                width: width * 0.16, 
                height: height - padding * 2 
            };
            
            // Calculate how many nodes can fit based on area and spacing
            function calculateNodeCount(bounds) {
                const area = bounds.width * bounds.height;
                const nodeArea = config.minNodeSpacing * config.minNodeSpacing;
                // Pack efficiently with hex packing factor (~0.9)
                return Math.floor((area / nodeArea) * 0.85);
            }
            
            const leftNodeCount = calculateNodeCount(leftBounds);
            const rightNodeCount = calculateNodeCount(rightBounds);
            const bridgeNodeCount = calculateNodeCount(bridgeBounds);
            
            let nodeId = 0;
            
            // Generate equally spaced random positions using Poisson disc sampling
            function poissonDiscSampling(bounds, numPoints, minDist) {
                const points = [];
                const cellSize = minDist / Math.sqrt(2);
                const gridWidth = Math.ceil(bounds.width / cellSize);
                const gridHeight = Math.ceil(bounds.height / cellSize);
                const grid = Array(gridWidth * gridHeight).fill(null);
                const active = [];
                
                // Helper to get grid cell
                const getCell = (x, y) => {
                    const col = Math.floor((x - bounds.x) / cellSize);
                    const row = Math.floor((y - bounds.y) / cellSize);
                    if (col < 0 || col >= gridWidth || row < 0 || row >= gridHeight) return -1;
                    return row * gridWidth + col;
                };
                
                // Start with random point
                const firstX = bounds.x + Math.random() * bounds.width;
                const firstY = bounds.y + Math.random() * bounds.height;
                points.push({x: firstX, y: firstY});
                active.push({x: firstX, y: firstY});
                grid[getCell(firstX, firstY)] = points.length - 1;
                
                let attempts = 0;
                const maxAttempts = numPoints * 50; // Prevent infinite loops
                
                while (active.length > 0 && points.length < numPoints && attempts < maxAttempts) {
                    attempts++;
                    const idx = Math.floor(Math.random() * active.length);
                    const point = active[idx];
                    let found = false;
                    
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = minDist + Math.random() * minDist;
                        const newX = point.x + Math.cos(angle) * radius;
                        const newY = point.y + Math.sin(angle) * radius;
                        
                        if (newX < bounds.x || newX >= bounds.x + bounds.width ||
                            newY < bounds.y || newY >= bounds.y + bounds.height) {
                            continue;
                        }
                        
                        const cell = getCell(newX, newY);
                        if (cell === -1) continue;
                        
                        let valid = true;
                        const searchRadius = 2;
                        const col = Math.floor((newX - bounds.x) / cellSize);
                        const row = Math.floor((newY - bounds.y) / cellSize);
                        
                        for (let dy = -searchRadius; dy <= searchRadius && valid; dy++) {
                            for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                                const checkCol = col + dx;
                                const checkRow = row + dy;
                                if (checkCol < 0 || checkCol >= gridWidth || checkRow < 0 || checkRow >= gridHeight) continue;
                                
                                const checkCell = checkRow * gridWidth + checkCol;
                                const otherIdx = grid[checkCell];
                                if (otherIdx !== null) {
                                    const other = points[otherIdx];
                                    const dist = Math.sqrt((newX - other.x) ** 2 + (newY - other.y) ** 2);
                                    if (dist < minDist) {
                                        valid = false;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (valid) {
                            points.push({x: newX, y: newY});
                            active.push({x: newX, y: newY});
                            grid[cell] = points.length - 1;
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        active.splice(idx, 1);
                    }
                }
                
                return points;
            }
            
            // Generate left nodes
            const leftPositions = poissonDiscSampling(leftBounds, leftNodeCount, config.minNodeSpacing);
            leftPositions.forEach(pos => {
                const node = new Node(pos.x, pos.y, 'left', nodeId++);
                leftNodes.push(node);
                allNodes.push(node);
            });
            
            // Generate right nodes
            const rightPositions = poissonDiscSampling(rightBounds, rightNodeCount, config.minNodeSpacing);
            rightPositions.forEach(pos => {
                const node = new Node(pos.x, pos.y, 'right', nodeId++);
                rightNodes.push(node);
                allNodes.push(node);
            });
            
            // Generate bridge nodes
            const bridgePositions = poissonDiscSampling(bridgeBounds, bridgeNodeCount, config.minNodeSpacing);
            bridgePositions.forEach(pos => {
                const node = new Node(pos.x, pos.y, 'bridge', nodeId++);
                bridgeNodes.push(node);
                allNodes.push(node);
            });
            
            // Spatially connect each hemisphere (only nearby nodes)
            leftNodes.forEach(node => {
                leftNodes.forEach(other => {
                    if (node !== other) {
                        const dx = other.x - node.x;
                        const dy = other.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        // Only connect if within max distance
                        if (distance <= config.maxConnectionDistance) {
                            node.neighbors.push({node: other, distance});
                        }
                    }
                });
            });
            
            rightNodes.forEach(node => {
                rightNodes.forEach(other => {
                    if (node !== other) {
                        const dx = other.x - node.x;
                        const dy = other.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        // Only connect if within max distance
                        if (distance <= config.maxConnectionDistance) {
                            node.neighbors.push({node: other, distance});
                        }
                    }
                });
            });
            
            // Connect bridges to each other (spatial)
            bridgeNodes.forEach(node => {
                bridgeNodes.forEach(other => {
                    if (node !== other) {
                        const dx = other.x - node.x;
                        const dy = other.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= config.maxConnectionDistance) {
                            node.neighbors.push({node: other, distance});
                        }
                    }
                });
            });
            
            // Connect left nodes to nearby bridges only
            leftNodes.forEach(leftNode => {
                bridgeNodes.forEach(bridge => {
                    const dx = bridge.x - leftNode.x;
                    const dy = bridge.y - leftNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= config.maxConnectionDistance * 1.5) { // Slightly longer range for bridge connections
                        leftNode.neighbors.push({node: bridge, distance});
                        bridge.neighbors.push({node: leftNode, distance});
                    }
                });
            });
            
            // Connect right nodes to nearby bridges only
            rightNodes.forEach(rightNode => {
                bridgeNodes.forEach(bridge => {
                    const dx = bridge.x - rightNode.x;
                    const dy = bridge.y - rightNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= config.maxConnectionDistance * 1.5) { // Slightly longer range for bridge connections
                        rightNode.neighbors.push({node: bridge, distance});
                        bridge.neighbors.push({node: rightNode, distance});
                    }
                });
            });
            
            // Create players
            leftPlayer = new Player('left', leftNodes);
            rightPlayer = new Player('right', rightNodes);
        }

        function drawConnections() {
            ctx.strokeStyle = config.colors.connections;
            ctx.globalAlpha = config.connectionOpacity;
            ctx.lineWidth = 1;
            
            allNodes.forEach(node => {
                node.neighbors.forEach(({node: neighbor}) => {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(neighbor.x, neighbor.y);
                    ctx.stroke();
                });
            });
            
            ctx.globalAlpha = 1;
        }

        function spawnMessage() {
            const side = Math.random() > 0.5 ? 'left' : 'right';
            const player = side === 'left' ? leftPlayer : rightPlayer;
            const targetSide = side === 'left' ? 'right' : 'left';
            // Each side sends their team color!
            const color = side === 'left' ? '#00d9ff' : '#00ff88'; // Cyan for left, green for right
            
            messages.push(new Message(player.currentNode, targetSide, color));
        }

        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
            ctx.fillRect(0, 0, width, height);

            drawConnections();

            // Highlight nodes that currently have messages waiting.
            const waitingCounts = getWaitingMessageCountsByNode();
            allNodes.forEach((node) => {
                node.active = (waitingCounts.get(node) || 0) > 0;
            });
            
            // Draw nodes
            allNodes.forEach(node => node.draw());
            
            // Update and draw messages (they never disappear)
            messages.forEach(message => {
                message.update();
                message.draw();
            });
            
            // Update and draw players
            leftPlayer.update();
            rightPlayer.update();
            leftPlayer.draw();
            rightPlayer.draw();
            
            requestAnimationFrame(animate);
        }

        // Initialize
        initializeGraph();
        animate();

        // Spawn messages periodically
        setInterval(() => {
            if (messages.length < 20) {
                spawnMessage();
            }
        }, 800);

        // Initial messages
        for (let i = 0; i < 5; i++) {
            setTimeout(spawnMessage, i * 300);
        }
    </script>
</body>
</html>
