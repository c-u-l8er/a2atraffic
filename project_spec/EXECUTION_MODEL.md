# A2A Traffic Execution Model

A2A Traffic is the portfolio’s event routing agent. This document defines **delivery semantics**, **ack/retry behavior**, **idempotency**, and **retention** so other components (OpenSentience Core, FleetPrompt, Delegatic, Graphonomous) can integrate without ambiguity.

This spec is written to align with portfolio standards:

- Signals are immutable facts; directives represent controlled intent.
- Durable artifacts must be secret-free.
- Dedupe and idempotency are mandatory safety features.
- Permissions are **bus-agnostic**:
  - `event:publish:<topic-or-pattern>`
  - `event:subscribe:<topic-or-pattern>`

---

## 1) Definitions

### 1.1 Event (envelope)
An **event** is an immutable, durable record emitted by a publisher and routed to subscribers.

Required fields:

- `topic` (string) — namespaced topic (e.g. `deploy.prod.success`)
- `message_id` (string) — source-specific unique id (preferred) or generated by A2A if absent
- `occurred_at` (timestamp) — when the source says it occurred
- `published_at` (timestamp) — when A2A accepted it (assigned by A2A)
- `source` (string) — publisher agent id or external adapter id
- `payload` (object) — JSON-safe, **secret-free**
- `dedupe_key` (string) — canonical idempotency key for A2A ingestion (see §2)

Recommended fields:

- `correlation_id` (string) — ties into cross-system audit timelines
- `causation_id` (string) — upstream event/directive/tool call id
- `schema_version` (string) — publisher-defined schema version for the payload

### 1.2 Subscription
A **subscription** binds a subscriber to a topic pattern (wildcards allowed by policy) and optionally a handler name.

Subscription fields (conceptual):

- `subscriber_id` (string) — agent id
- `pattern` (string) — topic match expression
- `handler` (string) — subscriber-side handler identifier (opaque to A2A)
- `filters` (object) — optional filter predicates (see §4.3)
- `priority` (string|int) — optional routing priority

### 1.3 Delivery attempt
A **delivery attempt** is a single attempt to deliver one event to one subscription endpoint (subscriber).

Attempt fields (conceptual):

- `attempt_id`
- `event_id` (A2A internal id)
- `subscription_id`
- `attempt_no` (1..N)
- `status`: `pending | delivering | acked | nacked | timed_out | failed | dead_lettered`
- `next_attempt_at` (timestamp, if retry scheduled)
- `last_error` (sanitized error string/code)

### 1.4 Ack / Nack
- **Ack**: subscriber confirms it has accepted the event for handling, and A2A can mark the delivery attempt successful.
- **Nack**: subscriber declines, causing retry scheduling or dead-lettering depending on policy.

Important: An ack indicates *delivery acceptance*, not necessarily successful completion of downstream work. If subscribers need end-to-end “work completed” semantics, they should emit a follow-up event (or a directive lifecycle signal) with correlation links.

---

## 2) Ingestion and idempotency (publisher-facing)

### 2.1 Acceptance contract
When A2A accepts a publish request, it must:

1. validate schema shape (envelope required fields; payload JSON-safe)
2. enforce permissions:
   - publisher must have `event:publish:<topic-or-pattern>`
3. compute / validate `dedupe_key`
4. persist the event durably (audit log) before acknowledging acceptance
5. enqueue routing fanout for matched subscriptions

A2A should not “accept” a publish without durable persistence (to avoid phantom events).

### 2.2 Dedupe keys (required)
A2A ingestion is idempotent via `dedupe_key`.

Rules:

- If publisher provides `dedupe_key`, A2A uses it.
- Else, if publisher provides a stable `message_id`, A2A should set `dedupe_key = "<source>:<message_id>"`.
- Else, A2A generates a unique `message_id` and a dedupe key, but idempotency across retries becomes publisher’s responsibility (not recommended).

Duplicate ingestion handling:

- If an event with the same `dedupe_key` already exists:
  - A2A must return a stable reference to the existing event (no duplicate fanout should be created).
  - A2A should be safe under concurrent publish calls (atomic dedupe constraint).

### 2.3 Mutability / updates
Events are immutable once accepted.

If a publisher needs to correct data, it publishes a new event with a new `dedupe_key` and a causal link (`causation_id` referencing the prior event).

---

## 3) Delivery semantics

### 3.1 Guarantee: at-least-once delivery
A2A provides **at-least-once** delivery to subscribers.

Consequences:

- Subscribers must be idempotent.
- Duplicate deliveries can occur due to retries, timeouts, restarts, or network partitions.

A2A does **not** guarantee exactly-once semantics.

### 3.2 Ordering
Default stance:

- No global ordering guarantee across topics or subscribers.
- Optional best-effort ordering may be provided **per (subscriber_id, topic)** if A2A uses a per-subscriber queue, but consumers must not rely on ordering unless explicitly configured.

If ordering is required, define a subscriber-side ordering key and handle reordering/idempotency at the subscriber.

### 3.3 Delivery protocol (Core ↔ Agent routing)
A2A should deliver events to subscribers via OpenSentience Core tool routing (preferred), so Core can enforce permissions and audit:

- A2A requests delivery by invoking a subscriber-exposed tool or a Core-defined “event delivery endpoint” for that subscriber.

Canonical pattern (conceptual):

- Tool invoked: `<subscriber_id>/a2a_handle_event`
- Input: `{ event: <envelope>, subscription: <metadata> }`

If you choose a different handler tool name, it must be standardized portfolio-wide so A2A does not need bespoke per-agent wiring.

### 3.4 Ack contract
A2A marks a delivery attempt as `acked` when it receives an explicit ack response from the subscriber.

Ack payload should include:

- `event_id` (or `dedupe_key`)
- `subscription_id`
- `status`: `ok` or `nack`
- `reason` (optional, sanitized)
- `retryable` (optional boolean; only meaningful for nack)

Timeouts:

- If A2A does not receive a response within `ack_timeout_ms`, it marks the attempt `timed_out` and schedules retry.

---

## 4) Subscription matching, filtering, and security

### 4.1 Topic patterns
A2A supports subscription patterns. MVP-friendly options:

- dot-separated tokens with `*` for single-token wildcard:
  - `deploy.*.success` matches `deploy.prod.success`
- optionally `**` for multi-token wildcard (higher risk of overbroad subscriptions)

Pattern grammar must be deterministic and safe to evaluate (no arbitrary regex execution unless constrained).

### 4.2 Permission enforcement (required on both sides)
A2A must enforce:

- publisher permission: `event:publish:<topic-or-pattern>`
- subscriber permission: `event:subscribe:<topic-or-pattern>`

Notes:

- Pattern permissions must not allow privilege escalation:
  - If a subscription requests `pattern = "deploy.**"`, subscriber must have `event:subscribe:deploy.**` (or a broader approved scope).
- The portfolio should define whether `event:subscribe:*` is allowed at all (recommended: deny by default; reserved for admin/system agents).

### 4.3 Filters
Filters are optional predicates evaluated by A2A to reduce fanout.

Rules:

- Filter evaluation must be safe and deterministic.
- Filters must operate on **non-secret** envelope/payload fields only.
- If filters reference missing fields, they should evaluate to false (do not throw).

MVP filter types:

- equality match on a small set of allowed keys
- “in list” match for known keys

Avoid arbitrary scripting or regex filters in MVP.

### 4.4 Payload constraints
- Payload must be secret-free and JSON-safe.
- A2A should enforce a max payload size (configurable), rejecting overly large events.
- A2A should support key denylisting for common secret keys (best-effort), but must not rely on it as the only control.

---

## 5) Retry and failure model

### 5.1 Retry policy
A2A retries failed deliveries with exponential backoff.

Defaults (configurable):

- `max_attempts`: 10
- `ack_timeout_ms`: 30_000
- backoff: `base = 1s`, multiplier `2.0`, jitter `±20%`, max delay `15m`

Retry triggers:

- delivery timeout (`timed_out`)
- subscriber returned nack with `retryable = true`
- transient transport failure (connection refused, Core router temporary error)

Non-retryable failures:

- permission denied (subscriber not authorized)
- schema validation failure for delivery envelope (A2A bug or incompatible subscriber)
- explicit nack with `retryable = false`

### 5.2 Dead-letter queue (DLQ)
If a delivery exceeds `max_attempts` or hits a non-retryable failure, A2A must:

- mark attempt as `dead_lettered`
- emit a durable, secret-free audit signal/event describing:
  - `event_id`, `subscription_id`, `subscriber_id`
  - failure category and sanitized error
  - total attempts and last attempt timestamp

DLQ storage can be implemented as a separate durable table/log with references to the original event (no duplication of payload if payload is large).

### 5.3 Subscriber idempotency guidance
Subscribers must treat event handling as idempotent keyed by:

- `event.dedupe_key` (preferred)
- or (`event.source`, `event.message_id`) if stable

Subscriber should store an “already processed” marker (durable) if it performs side effects.

---

## 6) Retention, audit, and replay hooks

### 6.1 Durable audit log (required)
A2A must durably record:

- accepted publishes (event envelope metadata + payload, secret-free)
- delivery attempts and final outcomes (acked/dead-lettered)
- subscription changes (create/update/delete), including actor and timestamp

This audit trail is part of portfolio-wide security posture.

### 6.2 Retention policy (configurable)
Retention is an implementation decision but must be configurable.

Minimum controls:

- `events_retention_days` (e.g. 7/30/90)
- `attempts_retention_days` (can be shorter/longer than events)
- `dlq_retention_days`

Compaction options (future):

- keep full payload only for N days; thereafter keep metadata + hash
- compress payloads
- tenant/company scoped retention overrides (Delegatic companies)

### 6.3 Replay (optional, but planned)
If replay is supported, it must be explicit and auditable.

Replay requirements:

- Replay operates on a bounded selection (by time range, topic, correlation_id).
- Replay emits events through the same routing and permission checks.
- Replay must prevent “cost explosion”:
  - rate limits, quotas, and dry-run mode (counts only)
- Replay should include a “replay marker” in the envelope metadata so subscribers can handle differently if needed.

Replay should be initiated via explicit directive(s) (recommended), not an unguarded tool call.

---

## 7) Cancellation and shutdown semantics

### 7.1 In-flight delivery cancellation
A2A may support canceling a pending delivery batch (e.g. shutdown, admin action). Cancellation must:

- mark affected attempts as `failed` or `canceled` with a sanitized reason
- allow resumption on restart (if at-least-once delivery is required)

### 7.2 Agent restarts
A2A must be restart-safe:

- accepted events remain durable
- pending delivery attempts are reloaded and retried
- dedupe constraints prevent duplicated fanout creation

---

## 8) Observability and metrics (minimum viable)

A2A should expose (internally and/or via Core UI):

- publish rate (events/min)
- delivery rate
- ack latency (p50/p95)
- retry counts and DLQ counts
- top topics by volume
- per-subscriber failure rates

All observability outputs must remain secret-free.

---

## 9) MVP defaults (recommended)
For the first implementation slice:

- Durable event log enabled (required)
- At-least-once delivery enabled
- Exponential backoff retries with DLQ
- Pattern matching with `*` single-token wildcard only
- Filters limited to simple equality / in-list
- No replay (only retention hooks + audit trail); add replay after quotas exist

---

## 10) Open questions (explicit)
1. Should A2A store full payloads for the entire retention period, or compact to metadata+hash after a shorter window?
2. Should ordering guarantees be offered as an opt-in per-subscription queue, or explicitly “no ordering” always?
3. What is the standardized subscriber handler tool name and input schema for event delivery (e.g. `a2a_handle_event`)?
4. Where should durable storage live (Core-owned vs A2A-owned), and how does Core query/merge audit timelines across agents?